I"a(<h2 id="css---flex">CSS - Flex</h2>

<h3 id="为什么会出现flex">为什么会出现Flex</h3>

<p>布局传统的解决方案是：display + position + float，或事用table、float、inline-block等来布局网站内容，但是这些方式对于复杂页面布局的实现非常麻烦，一个明显的例子就是<code class="language-plaintext highlighter-rouge">垂直居中</code>。那么Flex就出现了，它使得网站的布局更加地方便且容易，并且对响应式也非常友好。</p>

<h3 id="兼容性">兼容性</h3>

<p><img src="/assets/flex/flex-compatibility.png" alt="flex-compatibility" /></p>

<p>参考<a href="https://caniuse.com/#feat=flexbox">caniuse</a>网站，可以看到对IE11的支持还有有些bug存在，所以在用flex的时候还是要慎重。</p>

<h3 id="使用">使用</h3>

<p>使用flexbox非常简单，只需要给容易设置一个<code class="language-plaintext highlighter-rouge">display</code>属性即可；</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  .flex-container {
    display: -webkit-flex; /* Safari */
    display: flex;
  }
</code></pre></div></div>

<p>对行内元素同样可以使用flexbox布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  .flex-container {
    display: inline-lex;
  }
</code></pre></div></div>

<h3 id="基本概念">基本概念</h3>

<p><img src="/assets/flex/flex-concept.jpeg" alt="flex-concept" /></p>

<ul>
  <li>flex item， 采用了flex布局，它的所有子元素自动成为容器的成员，被称为<code class="language-plaintext highlighter-rouge">flex item</code>；</li>
  <li>flex line， <code class="language-plaintext highlighter-rouge">flex item</code>是沿着轴线（<code class="language-plaintext highlighter-rouge">flex line</code>）定位在容器内的，默认情况下每一个flex容器只有一条flex line；</li>
  <li>main axis和cross axis，容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），主轴的开始位置（与边框的交叉点）叫做<code class="language-plaintext highlighter-rouge">main start</code>，结束位置叫做<code class="language-plaintext highlighter-rouge">main end</code>；交叉轴的开始位置叫做<code class="language-plaintext highlighter-rouge">cross start</code>，结束位置叫做<code class="language-plaintext highlighter-rouge">cross end</code>。</li>
</ul>

<h3 id="容器的属性">容器的属性</h3>

<p><strong><code class="language-plaintext highlighter-rouge">flex-direction</code>属性，决定主轴的方向（即<code class="language-plaintext highlighter-rouge">flex item</code>的排列方向）。</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  .container {
    flex-direction: row | row-reverse | column | column-reverse;
  }
</code></pre></div></div>
<p><img src="/assets/flex/flex-direction.png" alt="flex-direction" /></p>

<ul>
  <li>row（默认值）：主轴为水平方向，起点在左端。</li>
  <li>row-reverse：主轴为水平方向，起点在右端。</li>
  <li>column：主轴为垂直方向，起点在上沿。</li>
  <li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">justify-content</code>属性，定义了<code class="language-plaintext highlighter-rouge">flex item</code>在主轴上的对齐方式。</strong></p>

<p><img src="/assets/flex/flex-justify-content.png" alt="flex-justify-content" /></p>

<ul>
  <li>flex-start（默认值）：左对齐</li>
  <li>flex-end：右对齐</li>
  <li>center： 居中</li>
  <li>space-between：两端对齐，项目之间的间隔都相等。</li>
  <li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">align-items</code>属性，定义了<code class="language-plaintext highlighter-rouge">flex item</code>在交叉轴的对齐方式。</strong></p>

<p><img src="/assets/flex/flex-align-items.png" alt="flex-align-items" /></p>

<ul>
  <li>flex-start（默认值）：交叉轴的起点对齐。</li>
  <li>flex-end：交叉轴的终点对齐。</li>
  <li>center：交叉轴的中点对齐。</li>
  <li>baseline: 项目的第一行文字的基线对齐。ps:很遗憾怎么都没办法实现这个baseline的效果，根据个人经验基本上也用不到。</li>
  <li>stretch：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">flex-wrap</code>属性，默认情况下，<code class="language-plaintext highlighter-rouge">flex item</code>都排在”轴线”（<code class="language-plaintext highlighter-rouge">flex line</code>）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</strong></p>

<p><img src="/assets/flex/flex-wrap.png" alt="flex-wrap" /></p>

<p>这里要特别注意默认的<code class="language-plaintext highlighter-rouge">no-wrap</code>，当<code class="language-plaintext highlighter-rouge">flex-item</code>宽度以及margin等的总和大于<code class="language-plaintext highlighter-rouge">container</code>的宽度时，会按照百分比来撑满父容器。</p>

<p><strong><code class="language-plaintext highlighter-rouge">align-content</code>属性，定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p>

<p><img src="/assets/flex/flex-align-content.png" alt="flex-align-content" /></p>

<ul>
  <li>stretch（默认值）：轴线占满整个交叉轴。</li>
  <li>flex-start：与交叉轴的起点对齐。</li>
  <li>flex-end：与交叉轴的终点对齐。</li>
  <li>center：与交叉轴的中点对齐。</li>
  <li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
  <li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">flex-flow</code>属性，是<code class="language-plaintext highlighter-rouge">flex-direction</code>和<code class="language-plaintext highlighter-rouge">flex-wrap</code>的简写。</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flex-flow: [flex-direction] [flex-wrap]
</code></pre></div></div>

<h3 id="flex-items的属性"><code class="language-plaintext highlighter-rouge">flex items</code>的属性</h3>

<p><strong><code class="language-plaintext highlighter-rouge">order</code>属性，定义<code class="language-plaintext highlighter-rouge">flex-item</code>的排列顺序。数值越小，排列越靠前，默认为0。</strong></p>

<p><img src="/assets/flex/flex-order.png" alt="flex-order" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">margin</code>属性，是我们非常熟悉的css属性，但在flex中更加强大，可以吸收多余的空间，使得flex items可以放到不同的位置。</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.item1 {
  width: 50px;
  margin-right: auto;
}
</code></pre></div></div>
<p><img src="/assets/flex/flex-margin-auto.png" alt="flex-margin-auto" /></p>

<p>这里，<code class="language-plaintext highlighter-rouge">margin-right: auto;</code>使得多余的空间被右侧的元素吸收。</p>

<p><strong><code class="language-plaintext highlighter-rouge">align-self</code>属性，允许该item与其他items有不一样的对齐方式，可以覆盖<code class="language-plaintext highlighter-rouge">align-items</code>属性。</strong></p>

<p><img src="/assets/flex/flex-align-self.png" alt="flex-align-self" /></p>

<p>这里服容器给定所有items相对于交叉轴居中，而第二个item设定<code class="language-plaintext highlighter-rouge">align-self: flex-start</code>，即可实现与别的items不一样的位置。</p>

<p><img src="/assets/flex/flex-grow.png" alt="flex-grow" /></p>

<p>这里，第一个item有一个固定宽度，item2和item3分别给定<code class="language-plaintext highlighter-rouge">flex-grow: 1</code>，即可将剩余空间平分。也可以对某一个item设定<code class="language-plaintext highlighter-rouge">flex-grow: 2</code>，就是2:1的关系了。</p>

<p><strong><code class="language-plaintext highlighter-rouge">flex</code>属性，是flex-grow, flex-shrink 和 flex-basis的简写。后两个属性可选。</strong></p>

<p>前面我们提到说如果所有item加起来的宽度大于父容器的宽度，则会按照百分比来填充父容器。那么flex有一个简单的方法来实现百分比填充的效果。简单地使用<code class="language-plaintext highlighter-rouge">flex: [number]</code>就能够实现。如果所有item的flex值为1，那么就是把剩余空间平分。</p>

<p><code class="language-plaintext highlighter-rouge">flex</code>还可以设定几个值：<code class="language-plaintext highlighter-rouge">flex: initial</code>,<code class="language-plaintext highlighter-rouge">flex: auto</code>,<code class="language-plaintext highlighter-rouge">flex: none</code>。</p>

<p>总结css的内容是相当繁琐的，我从早上八点开始写，写到现在，当然从中我也收获不少。当你厌倦了用传统的方式实现复杂布局的时候，试试flex吧，能极大地提高前端开发人员的幸福度哟。</p>

<hr />

<ol>
  <li><a href="https://bocoup.com/blog/dive-into-flexbox">https://bocoup.com/blog/dive-into-flexbox</a>；</li>
  <li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a>；</li>
  <li><a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties</a>;</li>
  <li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a>;</li>
</ol>
:ET